<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding and Talking</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://moqimoqidea.github.io/"/>
  <updated>2018-11-23T05:59:40.630Z</updated>
  <id>http://moqimoqidea.github.io/</id>
  
  <author>
    <name>moqi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM GC 发展历程</title>
    <link href="http://moqimoqidea.github.io/2017/06/16/JVM-GC-Development-Path/"/>
    <id>http://moqimoqidea.github.io/2017/06/16/JVM-GC-Development-Path/</id>
    <published>2017-06-16T08:29:47.000Z</published>
    <updated>2018-11-23T05:59:40.630Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍 JVM GC 的发展。</p><a id="more"></a> <h1 id="较早的-From-To-阶段"><a href="#较早的-From-To-阶段" class="headerlink" title="较早的 From - To 阶段"></a>较早的 From - To 阶段</h1><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/The-Oldest-GC.png?raw=true" alt="The-Oldest-GC"></p><ul><li>最早的垃圾收集 From - To 架构的 GC，把整个堆内存分成大小差不多相等的两部分，中间有一个分配的指针（Free Point），对指针设定目标值（比如 From 区域的 80%）时，触发一次 GC。GC 触发时应用进入 Stop-The-World 状态，这时垃圾回收器检查 From 区域有哪些是可以回收的那些不是，将不可以回收的拷贝到 To 区域，其他回收。一次 GC 操作完成的时候完成区域交换（From 转换为 To 区域，To 转换为 From 区域），然后指针分配内存开始从新的 From 区域开始。</li><li>这种纯粹的拷贝垃圾回收方法最大的问题在于堆内存里面永远只可以用一半的内存，所以有一半的堆是浪费的。但在当时而言还是比较领先的，比如相对于引用计数的垃圾回收方法。引用计数垃圾回收的问题在于：引用计数在计数的时候需要维持一个锁的消耗，会降低分配内存的速度；另外一个是在循环引用中，这个消耗会更大。</li></ul><h1 id="回收分代的思想"><a href="#回收分代的思想" class="headerlink" title="回收分代的思想"></a>回收分代的思想</h1><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/object-age-based-on-GC-generation-generational-hypothesis.png?raw=true" alt="object-age-based-on-GC-generation-generational-hypothesis"></p><ul><li>将堆内存分代治理建立于这样一个假设之上：<a href="https://plumbr.io/handbook/garbage-collection-in-java/generational-hypothesis" target="_blank" rel="noopener">代际假设</a> , 核心论点有两个：<ul><li>大多数对象很快就会被闲置；</li><li>少部分活下来的对象会存在相当长一段时间。</li></ul></li></ul><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/Hotspot-Heap-Structure.PNG?raw=true" alt="Hotspot-Heap-Structure"></p><ul><li>因此，JVM GC 分代治理的核心基础是以下两个：（1）大多数对象都会在年轻代死亡。（2）年老代引用年轻代的对象只占很小的一部分。分代治理会发生不同区域的 GC。在年轻代发生的 GC 称为 “minor GC”，在年老代出现的 GC 称为 “major GC” 或者 “full GC”。</li><li>根据代际假设构建的堆内存首先避免了全盘扫描，这个时期的 JVM GC 发展为如上图所示结构，分为年轻代，年老代，永生代。年轻代分为 eden 区与两个 survivor 区，s0 和 s1 实现是最初的 From - To 架构，在这里我们假设 s0 为 From 区，s1 为 To 区。创建的对象首先进入 eden 区，如果发生 minor GC，eden 区中大部分对象被回收，小部分对象拷贝到 To 区，From 也拷贝到 To 区；如果在 eden 中的对象太大不能拷贝到 To 区，则会被直接移动到年老代。每次 minor GC 时 From 和 To 会交换，每交换一次区内的对象年龄会加一，当年龄到达一定值（比如15）（注：这一块在后面的 GC 实现了动态调整）的时候，这些大龄的对象也被移动到了年老代。</li></ul><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/young-to-old-generation.png?raw=true" alt="yount-to-old-generation"></p><ul><li>但是这里会发生一个问题：<strong>如果年老代的对象需要引用年轻代的对象怎么办？</strong>为了处理这些情况，年老代中有一种称为”CardTable” (卡表) 的东西，它是一个 512 字节的块。每当年老代中的对象引用年轻代中的对象时，它就会记录在此表中。当发生 minor GC 时，仅搜索该卡表以确定它是否是年轻代 GC 需要回收的对象，而不是检查旧代中的所有对象的引用。</li></ul><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/card-table-structure.png?raw=true" alt="card-table-structure"></p><ul><li>当数据已满时，触发年老代执行 GC 。执行程序因 GC 类型而异，根据JDK 7，有5种GC类型。<ul><li>Serial GC</li><li>Parallel GC</li><li>Parallel Old GC (Parallel Compacting GC)</li><li>Concurrent Mark &amp; Sweep GC  (or “CMS”)</li><li>Garbage First (G1) GC<h2 id="Serial-GC"><a href="#Serial-GC" class="headerlink" title="Serial GC"></a>Serial GC</h2>(-XX:+UseSerialGC)，即串行 GC，使用被称为 “mark-sweep-compant” 的算法。</li><li>第一步：标记年老代中幸存的对象。（标记 - mark）</li><li>第二步：从堆的最前面开始检查，只留下幸存的堆。（扫描 - sweep）</li><li>第三步：把对象从最前面开始填充，以便连续堆积对象，并将堆分为包含对象和不包含对象的两部分。（紧凑 - compant）</li><li>串行 GC 适用于小内存和少量 CPU 内核的 JVM。<h2 id="Parallel-GC"><a href="#Parallel-GC" class="headerlink" title="Parallel GC"></a>Parallel GC</h2>(-XX:+UseParallelGC)，即并行 GC，和串行 GC 最大的区别是用多个线程来处理 GC，因此更快，当有足够的内存和 CPU 资源时，此 GC 非常有用，它也被称为”吞吐量 GC“。</li></ul></li></ul><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/Difference-between-the-Serial-GC-and-Parallel-GC.png?raw=true" alt="Difference-between-the-Serial-GC-and-Parallel-GC"></p><h2 id="Parallel-Old-GC"><a href="#Parallel-Old-GC" class="headerlink" title="Parallel Old GC"></a>Parallel Old GC</h2><p>  (-XX:+UseParallelOldGC)，并行旧 GC，自 JDK 5 更新以来开始支持，与并行 GC 相比，唯一的区别是老年代的 GC 算法。它经历了三个步骤：mark – summary – compaction（标记 - 摘要 - 压缩）。”摘要“步骤经历了一些更复杂的步骤。</p><h2 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h2><p>  （-XX：+ UseConcMarkSweepGC），从下图中可以看出，CMS GC 相对于前三个复杂得多。第一步 “Initial Mark” (初始标记) 很简单，搜索最接近类加载器的对象中的幸存对象，因此暂停时间很短。在 “Concurrent Mark” (并发标记) 步骤中，跟踪并检查刚刚确认的幸存对象引用的对象。这一步的不同之处在于它在同时处理其他线程的同时继续进行。在 “Remark” (再次标记) 步骤中，将检查在并发标记步骤中新增加或停止引用的对象。最后，在 “Concurrent Sweep” (并发扫描) 步骤中进行垃圾回收，垃圾回收和其他线程同步进行。由于 CMS GC 独特的运行方式，因此 GC 的暂停时间非常短。CMS GC 也称为低延迟 GC。<strong>在应用程序的响应时间至关重要时使用。</strong>这种 GC 的主要缺点如下：（1）它比其他 GC 类型使用更多的内存和 CPU。（2）默认情况下不提供压缩步骤。因而如果由于许多内存碎片而需要执行压缩任务，那么 GC 需要的静止时间可能会比其他任何 GC 方式都要长。所以，如果在使用 CMS GC 的时候要尤其注意压缩任务执行的频率和持续时间。</p><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/Serial-GC-and-CMS-GC.png?raw=true" alt="Serial-GC-and-CMS-GC"></p><h1 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h1><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/G1-GC.png?raw=true" alt="G1-GC"></p><ul><li>G1 是 Garbage First 的缩写，最开始的 G1 完全抛弃分代收集的思想，开始于 JDK 1.7 Update 4，可以视为上图中所有的 “E”, “O”, “S” 标志消失，只分成不同的 Region (块)。实际上现在的 G1 GC 也有了分代的逻辑。G1 的实现一直以来都在不断的变化之中。</li><li>由前文所知每种 GC 都有出现的历史背景，比如串行 GC 是在内存和 CPU 比较小的情况下出现的；并行 GC 是在吞吐量出现巨大需求的时候出现的；而 CMS GC 则是对低延迟有了更高的需求，尽量拖延 full GC 出现的时间。那么，出现 G1这种形式的垃圾收集器的原因是什么？在 JVM GC 不断发展的过程中，已经出现了自适应的堆，也就是不需要手动调节年轻代与年老代的比例，以及年轻代对象进入年老代的年龄。这些自适应堆对更灵活的堆块产生了强烈的需求：如果将堆空间划分为很多个 Region，G1 可以将某一块指定为各种不同的代（可以是年老代，Eden 或者 Survivor 区），而且各个块在空间上不需要连续的在一起，有一个 List 将它们组织在一起，这样 G1 就很容易调整各个代之间的比例。</li></ul><h2 id="为什么-G1-被称为-G1？"><a href="#为什么-G1-被称为-G1？" class="headerlink" title="为什么 G1 被称为 G1？"></a>为什么 G1 被称为 G1？</h2><ul><li><p>G1 会在内部维护一个优先列表，通过一个合理的模型，计算出每个 Region 的收集成本和收益期望并量化，这样每次进行 GC 时，G1 总是会选择最适合的 Region（通常垃圾比较多）进行回收，使 GC 时间满足设置的条件。</p></li><li><p>G1通过引入 Remembered Set 来避免全堆扫描（前面所说的 CardTable 是其的一种实现）。Remembered Set 用于跟踪对象引用。G1 中每个 Region 都有对应的 Remembered Set 。当 JVM 发现内部的一个引用关系需要更新（对 Reference 类型进行写操作），则立即产生一个 Write Barrier 中断这个写操作，并检查Reference 引用的对象是否处于不同的 Region 之间（用分代的思想，就是新生代和老年代之间的引用）。如果是，则通过 CardTable 通知 G1，G1 根据 CardTable 把相关引用信息记录到被引用对象所属的 Region 的Remembered Set 中，并将 Remembered Set 加入 GC Root 。这样，在 G1 进行根节点枚举时就可以扫描到该对象而不会出现遗漏。</p></li><li><p>通俗解释第二条：如果一个 Region 的 Reference 越少，JVM 倾向于认为这块 Region 里面活着的对象越少，这个 Region 块是可回收的垃圾块的百分比就越大，这样回收这个 Region 的收益就越大。所以称这种算法为 Garbage First.</p></li></ul><h2 id="G1-GC-年轻代的回收"><a href="#G1-GC-年轻代的回收" class="headerlink" title="G1 GC 年轻代的回收"></a>G1 GC 年轻代的回收</h2><ol><li>当 JVM 启动时基于启动参数，JVM 要求操作系统分配一个大的连续内存块来托管 JVM 的堆，被划分为 2048 个 Region (块)。</li></ol><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/how-young-gc-works-in-g1-1.png?raw=true" alt="how-young-gc-works-in-g1-1"></p><ol start="2"><li>年轻代的块发生 “minor GC”，将活着的对象拷贝到 survivor 块（依然是 From - To 算法）。如果对象过大或者对象的年龄足够，会拷贝到年老代。</li></ol><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/how-young-gc-works-in-g1-2.png?raw=true" alt="how-young-gc-works-in-g1-2"></p><ol start="3"><li>结果：图三有新增的 “Recently Copied” 两块。</li></ol><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/how-young-gc-works-in-g1-3.png?raw=true" alt="how-young-gc-works-in-g1-3"></p><h2 id="G1-GC-年老代的回收"><a href="#G1-GC-年老代的回收" class="headerlink" title="G1 GC 年老代的回收"></a>G1 GC 年老代的回收</h2><ol><li>初始标记阶段：初始标记的活着的对象在年轻代的垃圾收集上。在日志中，被标记为 GC pause (young) (inital-mark).</li></ol><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/Initial-Marking-Phase.PNG?raw=true" alt="Initial-Marking-Phase"></p><ol start="2"><li>并行标记阶段，如果找到空区域（由”X”表示），则在 Remark 阶段立即将它们移除。此外，计算确定活跃度的信息。</li></ol><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/Concurrent-Marking-Phase.PNG?raw=true" alt="Concurrent-Marking-Phase"></p><ol start="3"><li>Remark 阶段，空区域被移除并回收，现在计算所有区域的区域活跃度。</li></ol><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/Remark-Phase.PNG?raw=true" alt="Remark-Phase"></p><ol start="4"><li>复制清理阶段，G1 选择具有最低”活跃度“的区域（比如引用其他 Region 最少的区域），那些可以最快收集的区域。这些区域与年轻代 GC 同时收集。这在日志中表示为 [GC pause (mixed)]。G1 实际上将 Stop-The-World 的操作放在一个时间区间，这样对应用性能和稳定性较好。</li></ol><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/Copying:Cleanup-Phase.PNG?raw=true" alt="Copying:Cleanup-Phase"></p><ol start="5"><li>复制清理阶段后，选择的区域已经被收集并压缩成图中所示的深蓝色区域和深绿色区域。</li></ol><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/After-Copying:Cleanup-Phase.PNG?raw=true" alt="After-Copying:Cleanup-Phase"></p><h2 id="JDK-8-中-JVM-的调整"><a href="#JDK-8-中-JVM-的调整" class="headerlink" title="JDK 8 中 JVM 的调整"></a>JDK 8 中 JVM 的调整</h2><p>JDK 8 的 JVM 去掉了永生代(PermGen)，用 Metaspace 来代替。Metaspace 使用系统的内存。</p><p><img src="https://github.com/onefansofworld/hexo_images/blob/master/JVM-GC-Development-Path/Metaspace-And-PermGen.png?raw=true" alt="Metaspace-And-PermGen"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote class="blockquote-center"><a href="https://www.cubrid.org/blog/understanding-java-garbage-collection" target="_blank" rel="noopener">https://www.cubrid.org/blog/understanding-java-garbage-collection</a></blockquote> <blockquote class="blockquote-center"><a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a></blockquote> <blockquote class="blockquote-center"><a href="https://blog.idrsolutions.com/2017/05/g1gc-java-9-garbage-collector-explained-5-minutes/" target="_blank" rel="noopener">https://blog.idrsolutions.com/2017/05/g1gc-java-9-garbage-collector-explained-5-minutes/</a></blockquote> <blockquote class="blockquote-center"><a href="https://www.sczyh30.com/posts/Java/jvm-gc-hotspot-implements/" target="_blank" rel="noopener">https://www.sczyh30.com/posts/Java/jvm-gc-hotspot-implements/</a></blockquote><blockquote class="blockquote-center"><a href="https://software.intel.com/en-us/blogs/2014/06/18/part-1-tuning-java-garbage-collection-for-hbase" target="_blank" rel="noopener">https://software.intel.com/en-us/blogs/2014/06/18/part-1-tuning-java-garbage-collection-for-hbase</a></blockquote><blockquote class="blockquote-center"><a href="https://blog.csdn.net/elinespace/article/details/78852469" target="_blank" rel="noopener">https://blog.csdn.net/elinespace/article/details/78852469</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍 JVM GC 的发展。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://moqimoqidea.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Linux 日志相关命令整理</title>
    <link href="http://moqimoqidea.github.io/2017/06/03/Linux-Check-Log-Commands/"/>
    <id>http://moqimoqidea.github.io/2017/06/03/Linux-Check-Log-Commands/</id>
    <published>2017-06-03T14:34:05.000Z</published>
    <updated>2018-11-23T01:30:07.208Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍开发中一些日志的常用操作。</p><a id="more"></a> <h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>n  是显示行号；相当于 nl 命令；例子如下：</p><ul><li>tail -100f test.log      实时监控 100 行日志</li><li>tail  -n  10  test.log   查询日志尾部最后 10 行的日志;</li><li>tail -n +10 test.log    查询 10 行之后的所有日志;</li></ul><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>跟 tail 是相反的，tail 是看后多少行日志；例子如下：</p><ul><li>head -n 10  test.log   查询日志文件中的头 10 行日志;</li><li>head -n -10  test.log   查询日志文件除了最后 10 行的其他所有日志;</li></ul><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>tac 是倒序查看，是 cat 单词反写；例子如下：</p><ul><li>cat -n test.log |grep “debug”   查询关键字的日志</li></ul><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>进入编辑查找：vi(vim) </p><ul><li>进入vim编辑模式：<ul><li>vim  filename</li><li>vim +n filename  进入特定行号日志</li></ul></li><li>输入命令“set nu” 显示行号</li><li>输入“/关键字”,按enter键查找</li><li>查找下一个，按“n”即可</li><li>退出：按ESC键后，接着再输入:号时，vi会在屏幕的最下方等待我们输入命令<ul><li>wq! 保存退出；</li><li>q! 不保存退出；</li></ul></li><li>切换方向</li><li>/关键字  　　注：正向查找，按n键把光标移动到下一个符合条件的地方</li><li>?关键字  　　注：反向查找，按shift+n 键，把光标移动到下一个符合条件的</li></ul><h2 id="搜索关键字附近的日志"><a href="#搜索关键字附近的日志" class="headerlink" title="搜索关键字附近的日志"></a><strong>搜索关键字附近的日志</strong></h2><ul><li>最常用的：cat -n filename |grep “关键字”</li><li>其他情况：<ul><li>cat filename | grep -C 5 ‘关键字’ 　　(显示日志里匹配字串那行以及前后5行)</li><li>cat filename | grep -B 5 ‘关键字’ 　　(显示匹配字串及前5行)</li><li>cat filename | grep -A 5 ‘关键字’ 　　(显示匹配字串及后5行)</li></ul></li></ul><h2 id="按行号查看-过滤出关键字附近的日志"><a href="#按行号查看-过滤出关键字附近的日志" class="headerlink" title="按行号查看 - 过滤出关键字附近的日志"></a>按行号查看 - 过滤出关键字附近的日志</h2><ol><li>cat -n test.log |grep “debug”  得到关键日志的行号</li><li>cat -n test.log |tail -n +92|head -n 20  选择关键字所在的中间一行. 然后查看这个关键字后 20 行的日志:<ul><li>tail -n +92 表示查询第 92 行之后的日志</li><li>head -n 20 则表示在前面的查询结果里再查后 20 条记录</li></ul></li></ol><h2 id="根据日期查询日志"><a href="#根据日期查询日志" class="headerlink" title="根据日期查询日志"></a>根据日期查询日志</h2><p>sed -n ‘/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p’  test.log</p><ul><li>特别说明:上面的两个日期必须是日志中打印出来的日志，否则无效；</li><li>先 grep ‘2014-12-17 16:17:20’ test.log 来确定日志中是否有该 时间点</li></ul><h2 id="日志内容特别多，打印在屏幕上不方便查看"><a href="#日志内容特别多，打印在屏幕上不方便查看" class="headerlink" title="日志内容特别多，打印在屏幕上不方便查看"></a>日志内容特别多，打印在屏幕上不方便查看</h2><ul><li>使用 more 和 less 命令，如： cat -n test.log |grep “debug” |more     这样就分页打印了,通过点击空格键翻页</li><li>使用 &gt;xxx.txt 将其保存到文件中，到时可以拉下这个文件分析，如：cat -n test.log |grep “debug”  &gt; debug.txt</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote class="blockquote-center"><a href="https://blog.csdn.net/yangkai_hudong/article/details/47783487" target="_blank" rel="noopener">https://blog.csdn.net/yangkai_hudong/article/details/47783487</a></blockquote> <blockquote class="blockquote-center"><a href="https://www.cnblogs.com/hunt/p/7064886.html" target="_blank" rel="noopener">https://www.cnblogs.com/hunt/p/7064886.html</a></blockquote> <blockquote class="blockquote-center"><a href="https://blog.csdn.net/dingnning/article/details/7189862" target="_blank" rel="noopener">https://blog.csdn.net/dingnning/article/details/7189862</a></blockquote> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍开发中一些日志的常用操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://moqimoqidea.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IDEA - Debugger 经验总结</title>
    <link href="http://moqimoqidea.github.io/2017/06/02/IDEA-Debugger/"/>
    <id>http://moqimoqidea.github.io/2017/06/02/IDEA-Debugger/</id>
    <published>2017-06-02T06:38:42.000Z</published>
    <updated>2018-11-22T06:54:24.902Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍 IDEA - Debugger 的一些操作。每个都有场景和操作说明，动态 Gif 图体积较大，请耐心等待。</p><p><strong>觉得图比较小的单击查看大图。</strong></p><a id="more"></a> <h2 id="分析外部堆栈跟踪"><a href="#分析外部堆栈跟踪" class="headerlink" title="分析外部堆栈跟踪"></a>分析外部堆栈跟踪</h2><p>把报错信息复制到 Analyze -&gt; Analyze Stacktrace，快速进入程序块。开发中经常可以看到生产环境有错误日志，依照此方法快速将日志导入项目，定位问题。</p><p>场景：</p><p><img src="https://raw.githubusercontent.com/onefansofworld/hexo_images/master/201806/Analysis_Static_Stacktrace.png" alt="scene01"></p><p>操作：</p><p><img src="https://raw.githubusercontent.com/onefansofworld/hexo_images/master/201806/Analyze_Stacktrace.gif" alt="operate01"></p><h2 id="返回到前一个堆栈帧"><a href="#返回到前一个堆栈帧" class="headerlink" title="返回到前一个堆栈帧"></a>返回到前一个堆栈帧</h2><p>IDEA 可在程序的执行流程中回退到先前的堆栈帧。要求不是最上面入口方法，选择 Drop Frame 后，等于未进入调用的方法。请注意：已经对全局状态进行的更改不会被恢复，只有本地变量会被重置。</p><p><img src="https://raw.githubusercontent.com/onefansofworld/hexo_images/master/201806/drop_frame.gif" alt="drop_frame"></p><h2 id="强制从当前方法返回"><a href="#强制从当前方法返回" class="headerlink" title="强制从当前方法返回"></a>强制从当前方法返回</h2><p>在当前堆栈帧中右键单击选择 Force Return 然后根据需要的返回类型输入即可。</p><p><img src="https://raw.githubusercontent.com/onefansofworld/hexo_images/master/201806/force_return.gif" alt="force_return"></p><h2 id="抛出一个异常"><a href="#抛出一个异常" class="headerlink" title="抛出一个异常"></a>抛出一个异常</h2><p>在当前堆栈帧中右键单击选择 Throw Exception 然后手动输入异常即可，比如 new NullPointerException();</p><p><img src="https://raw.githubusercontent.com/onefansofworld/hexo_images/master/201806/throw_expection.gif" alt="throw_exception"></p><h2 id="重新加载修改的类"><a href="#重新加载修改的类" class="headerlink" title="重新加载修改的类"></a>重新加载修改的类</h2><p>一般而言应用于在 Debugger 时发现未调用的方法有需要改动的地方，这时候修改未调用的方法，然后选择 Run -&gt; Reload Changed Classes, 快捷键 Alt + U, 然后 A. 这时候 Debugger 继续进行调用，则执行的调用方法逻辑为重新编译之后。底层逻辑是用到 JVM 的 hotSwap.</p><p><img src="https://raw.githubusercontent.com/onefansofworld/hexo_images/master/201806/reload_change_class.gif" alt="reload_change_class"></p><h2 id="分析-Java-Stream-操作"><a href="#分析-Java-Stream-操作" class="headerlink" title="分析 Java Stream 操作"></a>分析 Java Stream 操作</h2><p>IDEA Debugger 时可以可视化 Java Stream 进行的操作和对值数据的影响，需要断点停留在 Stream 上点击 Trace Current Stream Chain 按钮。</p><p><img src="https://raw.githubusercontent.com/onefansofworld/hexo_images/master/201806/stream_trace.gif" alt="stream_trace"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote class="blockquote-center"><a href="https://www.jetbrains.com/help/idea/analyzing-external-stacktraces.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/analyzing-external-stacktraces.html</a></blockquote> <blockquote class="blockquote-center"><a href="https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html</a></blockquote> <blockquote class="blockquote-center"><a href="https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html</a></blockquote> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍 IDEA - Debugger 的一些操作。每个都有场景和操作说明，动态 Gif 图体积较大，请耐心等待。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;觉得图比较小的单击查看大图。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="IDEA" scheme="http://moqimoqidea.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Start</title>
    <link href="http://moqimoqidea.github.io/2017/06/01/Start/"/>
    <id>http://moqimoqidea.github.io/2017/06/01/Start/</id>
    <published>2017-06-01T14:02:59.000Z</published>
    <updated>2017-06-02T15:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文简要讨论了博客起源。</p><a id="more"></a> <ul><li>博客搭建于 20170601，儿童节做出的决定。</li><li>目前定位于分享技术和个人思考，狭义来讲技术在最近一段时间是开发工具 IntelliJ IDEA 的一些最佳实践，个人思考在最近一段时间是关于一些书的读后感。</li><li>目前对 Github + Hexo + NexT 刚开始熟悉，有建议欢迎联系邮箱。</li><li>Ernest Hemingway once wrote:”The world is a fine place，and worth fighting for.”I agree with the second part.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简要讨论了博客起源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="default" scheme="http://moqimoqidea.github.io/tags/default/"/>
    
  </entry>
  
</feed>
