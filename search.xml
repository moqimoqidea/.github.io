<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM GC 发展历程]]></title>
    <url>%2F2017%2F06%2F16%2FJVM-GC-Development-Path%2F</url>
    <content type="text"><![CDATA[本文主要介绍 JVM GC 的发展。 最早的垃圾收集 From - To 阶段 最早的垃圾收集 From - To 架构的 GC，把整个堆内存分成大小差不多相等的两部分，中间有一个分配的指针（Free Point），对指针设定目标值（比如 From 区域的 80%）时，触发一次 GC。GC 触发时应用进入 Stop-The-World 状态，这时垃圾回收器检查 From 区域有哪些是可以回收的那些不是，将不可以回收的拷贝到 To 区域，其他回收。一次 GC 操作完成的时候完成区域交换（From 转换为 To 区域，To 转换为 From 区域），然后指针分配内存开始从新的 From 区域开始。 这种纯粹的拷贝垃圾回收方法最大的问题在于堆内存里面永远只可以用一半的内存，所以有一半的堆是浪费的。但在当时而言还是比较领先的，比如相对于引用计数的垃圾回收方法。引用计数垃圾回收的问题在于：引用计数在计数的时候需要维持一个锁的消耗，会降低分配内存的速度；另外一个是在循环引用中，这个消耗会更大。 将垃圾回收分代的回收思想 将堆内存分代治理建立于这样一个假设之上：代际假设 , 核心论点有两个： 大多数对象很快就会被闲置； 少部分活下来的对象会存在相当长一段时间。 因此，JVM GC 分代治理的核心基础是以下两个： 大多数对象都会在年轻代死亡。 年老代引用年轻代的对象只占很小的一部分。 根据代际假设构建的堆内存首先避免了全盘扫描，这个时期的 JVM GC 发展为如上图所示结构，分为年轻代，年老代，永生代。年轻代分为 eden 区与两个 survivor 区，s0 和 s1 实现是最初的 From - To 架构，在这里我们假设 s0 为 From 区，s1 为 To 区。创建的对象首先进入 eden 区，如果发生年轻代垃圾回收，eden 区中大部分对象被回收，小部分对象拷贝到 To 区，From 也拷贝到 To 区；如果在 eden 中的对象太大不能拷贝到 To 区，则会被直接移动到年老代。每次年轻代的垃圾回收 From 和 To 会交换，每交换一次区内的对象年龄会加一，当年龄到达一定值（比如15）（注：这一块在后面的 GC 实现了动态调整）的时候，这些大龄的对象也被移动到了年老代。 但是这里会发生一个问题：如果年老代的对象需要引用年轻代的对象怎么办？为了处理这些情况，年老代中有一种称为“ 卡表 ”的东西，它是一个 512 字节的块。每当年老代中的对象引用年轻代中的对象时，它就会记录在此表中。当为年轻代执行 GC 时，仅搜索该卡表以确定它是否是年轻代 GC 需要回收的对象，而不是检查旧代中的所有对象的引用。 当数据已满时，触发年老代执行 GC 。执行程序因 GC 类型而异，根据JDK 7，有5种GC类型。 Serial GC Parallel GC Parallel Old GC (Parallel Compacting GC) Concurrent Mark &amp; Sweep GC (or “CMS”) Garbage First (G1) GCSerial GC (-XX:+UseSerialGC)即串行 GC，使用被称为 “mark-sweep-compant” 的算法。 第一步：标记年老代中幸存的对象。（标记 - mark） 第二步：从堆的最前面开始检查，只留下幸存的堆。（扫描 - sweep） 第三步：把对象从最前面开始填充，以便连续堆积对象，并将堆分为包含对象和不包含对象的两部分。（紧凑 - compant） 串行 GC 适用于小内存和少量 CPU 内核的 JVM。Parallel GC (-XX:+UseParallelGC)即并行 GC，和串行 GC 最大的区别是用多个线程来处理 GC，因此更快，当有足够的内存和 CPU 资源时，此 GC 非常有用，它也被称为”吞吐量 GC“。 Parallel Old GC(-XX:+UseParallelOldGC) 并行旧 GC，自 JDK 5 更新以来开始支持，与并行 GC 相比，唯一的区别是老年代的 GC 算法。它经历了三个步骤：mark – summary – compaction（标记 - 摘要 - 压缩）。”摘要“步骤经历了一些更复杂的步骤。 CMS GC（-XX：+ UseConcMarkSweepGC） 从下图中可以看出，CMS GC 相对于前三个复杂得多。第一步 “Initial Mark” (初始标记) 很简单，搜索最接近类加载器的对象中的幸存对象，因此暂停时间很短。在 “Concurrent Mark” (并发标记) 步骤中，跟踪并检查刚刚确认的幸存对象引用的对象。这一步的不同之处在于它在同时处理其他线程的同时继续进行。在 “Remark” (再次标记) 步骤中，将检查在并发标记步骤中新增加或停止引用的对象。最后，在 “Concurrent Sweep” (并发扫描) 步骤中进行垃圾回收，垃圾回收和其他线程同步进行。由于 CMS GC 独特的运行方式，因此 GC 的暂停时间非常短。CMS GC 也称为低延迟 GC。在应用程序的响应时间至关重要时使用。这种 GC 的主要缺点如下：（1）它比其他 GC 类型使用更多的内存和 CPU。（2）默认情况下不提供压缩步骤。因而如果由于许多内存碎片而需要执行压缩任务，那么 GC 需要的静止时间可能会比其他任何 GC 方式都要长。所以，如果在使用 CMS GC 的时候要尤其注意压缩任务执行的频率和持续时间。 G1 GC 待补充！]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 日志相关命令整理]]></title>
    <url>%2F2017%2F06%2F03%2FLinux-Check-Log-Commands%2F</url>
    <content type="text"><![CDATA[本文主要介绍开发中一些日志的常用操作。 tailn 是显示行号；相当于 nl 命令；例子如下： tail -100f test.log 实时监控 100 行日志 tail -n 10 test.log 查询日志尾部最后 10 行的日志; tail -n +10 test.log 查询 10 行之后的所有日志; head跟 tail 是相反的，tail 是看后多少行日志；例子如下： head -n 10 test.log 查询日志文件中的头 10 行日志; head -n -10 test.log 查询日志文件除了最后 10 行的其他所有日志; cattac 是倒序查看，是 cat 单词反写；例子如下： cat -n test.log |grep “debug” 查询关键字的日志 vim进入编辑查找：vi(vim) 进入vim编辑模式： vim filename vim +n filename 进入特定行号日志 输入命令“set nu” 显示行号 输入“/关键字”,按enter键查找 查找下一个，按“n”即可 退出：按ESC键后，接着再输入:号时，vi会在屏幕的最下方等待我们输入命令 wq! 保存退出； q! 不保存退出； 切换方向 /关键字 注：正向查找，按n键把光标移动到下一个符合条件的地方 ?关键字 注：反向查找，按shift+n 键，把光标移动到下一个符合条件的 搜索关键字附近的日志 最常用的：cat -n filename |grep “关键字” 其他情况： cat filename | grep -C 5 ‘关键字’ (显示日志里匹配字串那行以及前后5行) cat filename | grep -B 5 ‘关键字’ (显示匹配字串及前5行) cat filename | grep -A 5 ‘关键字’ (显示匹配字串及后5行) 按行号查看 - 过滤出关键字附近的日志 cat -n test.log |grep “debug” 得到关键日志的行号 cat -n test.log |tail -n +92|head -n 20 选择关键字所在的中间一行. 然后查看这个关键字后 20 行的日志: tail -n +92 表示查询第 92 行之后的日志 head -n 20 则表示在前面的查询结果里再查后 20 条记录 根据日期查询日志sed -n ‘/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p’ test.log 特别说明:上面的两个日期必须是日志中打印出来的日志，否则无效； 先 grep ‘2014-12-17 16:17:20’ test.log 来确定日志中是否有该 时间点 日志内容特别多，打印在屏幕上不方便查看 使用 more 和 less 命令，如： cat -n test.log |grep “debug” |more 这样就分页打印了,通过点击空格键翻页 使用 &gt;xxx.txt 将其保存到文件中，到时可以拉下这个文件分析，如：cat -n test.log |grep “debug” &gt; debug.txt 参考https://blog.csdn.net/yangkai_hudong/article/details/47783487 https://www.cnblogs.com/hunt/p/7064886.html https://blog.csdn.net/dingnning/article/details/7189862]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA - Debugger 经验总结]]></title>
    <url>%2F2017%2F06%2F02%2FIDEA-Debugger%2F</url>
    <content type="text"><![CDATA[本文主要介绍 IDEA - Debugger 的一些操作。每个都有场景和操作说明，动态 Gif 图体积较大，请耐心等待。 觉得图比较小的单击查看大图。 分析外部堆栈跟踪把报错信息复制到 Analyze -&gt; Analyze Stacktrace，快速进入程序块。开发中经常可以看到生产环境有错误日志，依照此方法快速将日志导入项目，定位问题。 场景： 操作： 返回到前一个堆栈帧IDEA 可在程序的执行流程中回退到先前的堆栈帧。要求不是最上面入口方法，选择 Drop Frame 后，等于未进入调用的方法。请注意：已经对全局状态进行的更改不会被恢复，只有本地变量会被重置。 强制从当前方法返回在当前堆栈帧中右键单击选择 Force Return 然后根据需要的返回类型输入即可。 抛出一个异常在当前堆栈帧中右键单击选择 Throw Exception 然后手动输入异常即可，比如 new NullPointerException(); 重新加载修改的类一般而言应用于在 Debugger 时发现未调用的方法有需要改动的地方，这时候修改未调用的方法，然后选择 Run -&gt; Reload Changed Classes, 快捷键 Alt + U, 然后 A. 这时候 Debugger 继续进行调用，则执行的调用方法逻辑为重新编译之后。底层逻辑是用到 JVM 的 hotSwap. 分析 Java Stream 操作IDEA Debugger 时可以可视化 Java Stream 进行的操作和对值数据的影响，需要断点停留在 Stream 上点击 Trace Current Stream Chain 按钮。 参考https://www.jetbrains.com/help/idea/analyzing-external-stacktraces.html https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Start]]></title>
    <url>%2F2017%2F06%2F01%2FStart%2F</url>
    <content type="text"><![CDATA[本文简要讨论了博客起源。 博客搭建于 20170601，儿童节做出的决定。 目前定位于分享技术和个人思考，狭义来讲技术在最近一段时间是开发工具 IntelliJ IDEA 的一些最佳实践，个人思考在最近一段时间是关于一些书的读后感。 目前对 Github + Hexo + NexT 刚开始熟悉，有建议欢迎联系邮箱。 Ernest Hemingway once wrote:”The world is a fine place，and worth fighting for.”I agree with the second part.]]></content>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
</search>
